
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAAI Experiment Service Interaction Flow (Auto-Generated)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #1e1e1e; color: #d4d4d4; line-height: 1.6; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: auto; background-color: #252526; border: 1px solid #3c3c3c; border-radius: 8px; padding: 25px; }
        h1, h2 { color: #9cdcfe; border-bottom: 2px solid #4a4a4a; padding-bottom: 10px; }
        .mermaid { background-color: #2a2d34; border: 1px solid #4a4a4a; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 30px; }
        .service-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 20px; }
        .service-card { background-color: #2a2d34; border: 1px solid #4a4a4a; border-radius: 8px; padding: 20px; display: flex; flex-direction: column; }
        .service-card h3 { margin-top: 0; color: #569cd6; }
        .service-card code { background-color: #1e1e1e; color: #ce9178; padding: 2px 6px; border-radius: 4px; font-family: "Fira Code", "Courier New", monospace; }
        .service-card ul { padding-left: 20px; margin-top: 10px; }
        .service-card li { margin-bottom: 8px; }
        .function-list { margin-top: 15px; border-top: 1px solid #4a4a4a; padding-top: 15px; }
        .function-list h4 { margin-top: 0; color: #4ec9b0; }
        .function-list dl { margin: 0; }
        .function-list dt { font-weight: bold; color: #dcdcaa; margin-top: 15px; }
        .function-list dd { margin-left: 20px; font-size: 0.9em; color: #c8c8c8; }
        .function-list dd ul { list-style-type: '- '; }
    </style>
</head>
<body>
    <div class="container">
        <h1>MAAI Experiment Service Interaction Flow</h1>
        <p>This document is dynamically generated by analyzing the project's source code. It provides a graphical and textual overview of the service interactions when <code>run_config.py</code> is executed.</p>
        <h2>Execution Sequence Diagram</h2>
        <div class="mermaid">
sequenceDiagram
    actor User
    participant EntryPoint as "run_config.py"
    participant DM as "DeliberationManager"
    participant EO as "ExperimentOrchestrator"
    participant CM as "ConfigManager"
    participant ConvS as "ConversationService"
    participant MemS as "MemoryService"
    participant ConS as "ConsensusService"
    participant EvalS as "EvaluationService"
    participant DE as "DataExporter"

    User->>EntryPoint: Executes python run_config.py
    activate EntryPoint

    EntryPoint->>CM: load_config_from_file()
    activate CM
    CM-->>EntryPoint: ExperimentConfig
    deactivate CM

    EntryPoint->>DM: run_single_experiment(config)
    activate DM

    DM->>EO: run_experiment(config)
    activate EO

    Note over EO: Phase 1: Initialization
    EO->>EO: _initialize_agents()
    EO->>MemS: initialize_agent_memory() for each agent
    activate MemS
    MemS-->>EO: memories initialized
    deactivate MemS

    Note over EO: Phase 2: Initial Likert Assessment
    EO->>ConvS: conduct_initial_likert_assessment()
    activate ConvS
    ConvS->>EvalS: conduct_initial_assessment()
    activate EvalS
    EvalS-->>ConvS: InitialEvaluationResponses
    deactivate EvalS
    ConvS-->>EO: InitialEvaluationResponses
    deactivate ConvS

    Note over EO: Phase 3: Initial Choice Evaluation
    EO->>ConvS: conduct_initial_evaluation()
    activate ConvS
    ConvS-->>EO: Transcript updated
    deactivate ConvS
    EO->>ConS: detect_consensus()
    activate ConS
    ConS-->>EO: Initial ConsensusResult
    deactivate ConS

    Note over EO: Phase 4: Deliberation Loop
    loop Deliberation Rounds
        EO->>ConvS: generate_speaking_order()
        activate ConvS
        ConvS-->>EO: Speaking Order
        deactivate ConvS

        EO->>ConvS: conduct_round()
        activate ConvS
        Note right of ConvS: For each agent in order...
        ConvS->>MemS: update_agent_memory()
        activate MemS
        MemS-->>ConvS: New MemoryEntry
        deactivate MemS
        ConvS->>ConvS: _generate_public_communication()
        ConvS-->>EO: Transcript updated
        deactivate ConvS

        EO->>ConS: detect_consensus()
        activate ConS
        ConS-->>EO: Round ConsensusResult
        deactivate ConS
        alt Consensus Reached
            EO->>EO: break loop
        end
    end

    Note over EO: Phase 5: Post-Consensus Evaluation
    EO->>EvalS: conduct_parallel_evaluation()
    activate EvalS
    EvalS-->>EO: Final EvaluationResponses
    deactivate EvalS

    Note over EO: Phase 6 & 7: Finalize
    EO->>EO: _collect_feedback()
    EO->>EO: _finalize_results()

    Note over EO: Phase 8: Export
    EO->>DE: export_experiment_data(results)
    activate DE
    DE-->>EO: File paths
    deactivate DE

    EO-->>DM: ExperimentResults
    deactivate EO
    DM-->>EntryPoint: ExperimentResults
    deactivate DM
    EntryPoint-->>User: Prints summary to console
    deactivate EntryPoint
        </div>
        <h2>Core Service Descriptions</h2>
        <div class="service-grid">
            
<div class="service-card">
    <h3>ConsensusService</h3>
    <code>src/maai/services/consensus_service.py</code>
    <p><strong>Role:</strong> Not specified.</p>
    <p>Service for detecting and validating consensus in deliberation.</p>
    <ul>
        <li><strong>Calls:</strong> None</li>
        <li><strong>Called by:</strong> ExperimentOrchestrator</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>
<dt><code>detect(responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>ConsensusResult</code><br/>
    <p>Detect consensus from deliberation responses.</p>
</dd>

<dt><code>detect(responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>ConsensusResult</code><br/>
    <p>Detect consensus by checking if all agents have the same principle_id.</p>
</dd>

<dt><code>detect(responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>ConsensusResult</code><br/>
    <p>Detect consensus by analyzing semantic similarity of reasoning.<br/>For now, falls back to ID matching.</p>
</dd>

<dt><code>detect(responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>ConsensusResult</code><br/>
    <p>Detect consensus based on threshold agreement.</p>
</dd>

<dt><code>detect_consensus(responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>ConsensusResult</code><br/>
    <p>Detect consensus using the configured strategy.</p>
</dd>

<dt><code>validate_consensus(result, responses)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>result</code>: ConsensusResult</li><li><code>responses</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>bool</code><br/>
    <p>Validate that consensus is genuine and not due to prompt engineering artifacts.</p>
</dd>

<dt><code>set_detection_strategy(strategy)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>strategy</code>: ConsensusDetectionStrategy</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Change the consensus detection strategy.</p>
</dd>
</dl>
    </div>
</div>

<div class="service-card">
    <h3>ConversationService</h3>
    <code>src/maai/services/conversation_service.py</code>
    <p><strong>Role:</strong> Not specified.</p>
    <p>Service for managing agent communication flow and patterns.</p>
    <ul>
        <li><strong>Calls:</strong> None</li>
        <li><strong>Called by:</strong> ExperimentOrchestrator</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>
<dt><code>generate_speaking_order(agents, round_num, previous_orders)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>round_num</code>: int</li><li><code>previous_orders</code>: List[List[str]]</li></ul>
    <strong>Output:</strong> <code>List[str]</code><br/>
    <p>Generate speaking order for a round.</p>
</dd>

<dt><code>generate_speaking_order(agents, round_num, previous_orders)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>round_num</code>: int</li><li><code>previous_orders</code>: List[List[str]]</li></ul>
    <strong>Output:</strong> <code>List[str]</code><br/>
    <p>Generate random speaking order with constraint.</p>
</dd>

<dt><code>generate_speaking_order(agents, round_num, previous_orders)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>round_num</code>: int</li><li><code>previous_orders</code>: List[List[str]]</li></ul>
    <strong>Output:</strong> <code>List[str]</code><br/>
    <p>Generate sequential speaking order.</p>
</dd>

<dt><code>generate_speaking_order(agents, round_num, previous_orders)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>round_num</code>: int</li><li><code>previous_orders</code>: List[List[str]]</li></ul>
    <strong>Output:</strong> <code>List[str]</code><br/>
    <p>Generate hierarchical speaking order.</p>
</dd>

<dt><code>get_agent_by_id(agent_id)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent_id</code>: str</li></ul>
    <strong>Output:</strong> <code>DeliberationAgent</code><br/>
    <p>Get agent by ID.</p>
</dd>

<dt><code>generate_speaking_order(agents, round_num)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>round_num</code>: int</li></ul>
    <strong>Output:</strong> <code>List[str]</code><br/>
    <p>Generate speaking order for a round.</p>
</dd>

<dt><code>conduct_initial_evaluation(agents, transcript)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>transcript</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>List[DeliberationResponse]</code><br/>
    <p>Conduct initial individual evaluation where each agent evaluates principles.</p>
</dd>

<dt><code>conduct_initial_likert_assessment(agents, evaluation_service)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List[DeliberationAgent]</li><li><code>evaluation_service</code>: Any</li></ul>
    <strong>Output:</strong> <code>List</code><br/>
    <p>Conduct initial Likert scale assessment of all principles (parallel).<br/>This is purely for data collection - no consensus detection or decision making.</p>
</dd>

<dt><code>conduct_round(round_context, memory_service, moderator)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>round_context</code>: RoundContext</li><li><code>memory_service</code>: Any</li><li><code>moderator</code>: Any</li></ul>
    <strong>Output:</strong> <code>List[DeliberationResponse]</code><br/>
    <p>Conduct a single round of deliberation.</p>
</dd>

<dt><code>get_speaking_orders()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>List[List[str]]</code><br/>
    <p>Get all speaking orders used so far.</p>
</dd>

<dt><code>set_communication_pattern(pattern)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>pattern</code>: CommunicationPattern</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Change the communication pattern.</p>
</dd>
</dl>
    </div>
</div>

<div class="service-card">
    <h3>EvaluationService</h3>
    <code>src/maai/services/evaluation_service.py</code>
    <p><strong>Role:</strong> Not specified.</p>
    <p>Service for conducting post-consensus principle evaluations.</p>
    <ul>
        <li><strong>Calls:</strong> None</li>
        <li><strong>Called by:</strong> ExperimentOrchestrator</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>
<dt><code>conduct_parallel_evaluation(agents, consensus_result, moderator_agent)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List</li><li><code>consensus_result</code>: ConsensusResult</li><li><code>moderator_agent</code>: Any</li></ul>
    <strong>Output:</strong> <code>List[AgentEvaluationResponse]</code><br/>
    <p>Conduct parallel evaluation of all principles by all agents.</p>
</dd>

<dt><code>conduct_initial_assessment(agents, dummy_consensus, moderator_agent)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agents</code>: List</li><li><code>dummy_consensus</code>: ConsensusResult</li><li><code>moderator_agent</code>: Any</li></ul>
    <strong>Output:</strong> <code>List[AgentEvaluationResponse]</code><br/>
    <p>Conduct initial Likert scale assessment (parallel).<br/>This is purely for data collection before any deliberation.</p>
</dd>
</dl>
    </div>
</div>

<div class="service-card">
    <h3>ExperimentOrchestrator</h3>
    <code>src/maai/services/experiment_orchestrator.py</code>
    <p><strong>Role:</strong> Not specified.</p>
    <p>High-level orchestrator for deliberation experiments.</p>
    <ul>
        <li><strong>Calls:</strong> ConsensusService, ConversationService, EvaluationService, MemoryService</li>
        <li><strong>Called by:</strong> None</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>
<dt><code>run_experiment(config)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>config</code>: ExperimentConfig</li></ul>
    <strong>Output:</strong> <code>ExperimentResults</code><br/>
    <p>Run a complete deliberation experiment.</p>
</dd>

<dt><code>get_experiment_state()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>dict</code><br/>
    <p>Get current experiment state for monitoring.</p>
</dd>

<dt><code>reset_experiment()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Reset orchestrator state for new experiment.</p>
</dd>
</dl>
    </div>
</div>

<div class="service-card">
    <h3>MemoryService</h3>
    <code>src/maai/services/memory_service.py</code>
    <p><strong>Role:</strong> Not specified.</p>
    <p>Centralized service for managing agent memory.</p>
    <ul>
        <li><strong>Calls:</strong> None</li>
        <li><strong>Called by:</strong> ExperimentOrchestrator</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>
<dt><code>should_include_memory(memory_entry, current_round)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>memory_entry</code>: MemoryEntry</li><li><code>current_round</code>: int</li></ul>
    <strong>Output:</strong> <code>bool</code><br/>
    <p>Determine if a memory entry should be included in context.</p>
</dd>

<dt><code>get_memory_context_limit()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>int</code><br/>
    <p>Get the maximum number of memory entries to include.</p>
</dd>

<dt><code>should_include_memory(memory_entry, current_round)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>memory_entry</code>: MemoryEntry</li><li><code>current_round</code>: int</li></ul>
    <strong>Output:</strong> <code>bool</code><br/>
    <p>Include all memory entries.</p>
</dd>

<dt><code>get_memory_context_limit()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>int</code><br/>
    <p>No limit on memory entries.</p>
</dd>

<dt><code>should_include_memory(memory_entry, current_round)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>memory_entry</code>: MemoryEntry</li><li><code>current_round</code>: int</li></ul>
    <strong>Output:</strong> <code>bool</code><br/>
    <p>Include if within recent limit (handled by get_memory_context_limit).</p>
</dd>

<dt><code>get_memory_context_limit()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>int</code><br/>
    <p>Return maximum recent entries.</p>
</dd>

<dt><code>should_include_memory(memory_entry, current_round)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>memory_entry</code>: MemoryEntry</li><li><code>current_round</code>: int</li></ul>
    <strong>Output:</strong> <code>bool</code><br/>
    <p>Include if within recent rounds.</p>
</dd>

<dt><code>get_memory_context_limit()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>int</code><br/>
    <p>No specific limit (handled by round filtering).</p>
</dd>

<dt><code>initialize_agent_memory(agent_id)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent_id</code>: str</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Initialize memory for an agent.</p>
</dd>

<dt><code>get_agent_memory(agent_id)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent_id</code>: str</li></ul>
    <strong>Output:</strong> <code>AgentMemory</code><br/>
    <p>Get agent memory, creating if necessary.</p>
</dd>

<dt><code>update_agent_memory(agent, round_number, speaking_position, transcript)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent</code>: DeliberationAgent</li><li><code>round_number</code>: int</li><li><code>speaking_position</code>: int</li><li><code>transcript</code>: List[DeliberationResponse]</li></ul>
    <strong>Output:</strong> <code>MemoryEntry</code><br/>
    <p>Update an agent's private memory before they speak.</p>
</dd>

<dt><code>get_all_agent_memories()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>List[AgentMemory]</code><br/>
    <p>Get all agent memories for export.</p>
</dd>

<dt><code>get_agent_memory_summary(agent_id)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent_id</code>: str</li></ul>
    <strong>Output:</strong> <code>Dict[str, any]</code><br/>
    <p>Get summary of agent's memory for analysis.</p>
</dd>

<dt><code>clear_agent_memory(agent_id)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>agent_id</code>: str</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Clear all memory for an agent.</p>
</dd>

<dt><code>clear_all_memories()</code></dt>
<dd>
    <strong>Input:</strong><ul><li>None</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Clear all agent memories.</p>
</dd>

<dt><code>set_memory_strategy(strategy)</code></dt>
<dd>
    <strong>Input:</strong><ul><li><code>strategy</code>: MemoryStrategy</li></ul>
    <strong>Output:</strong> <code>Any</code><br/>
    <p>Change the memory management strategy.</p>
</dd>
</dl>
    </div>
</div>

        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'dark' });</script>
</body>
</html>
