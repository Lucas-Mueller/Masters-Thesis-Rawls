

import os
import ast
import glob
from collections import defaultdict

# --- CONFIGURATION ---
# Dynamically determine project root and service directory
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
SERVICE_DIR = os.path.join(ROOT_DIR, "src/maai/services")
OUTPUT_FILE = os.path.join(ROOT_DIR, "docs/visualization/service_interaction_overview.html")

# --- HTML TEMPLATES ---
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAAI Experiment Service Interaction Flow (Auto-Generated)</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #1e1e1e; color: #d4d4d4; line-height: 1.6; margin: 0; padding: 20px; }}
        .container {{ max-width: 1200px; margin: auto; background-color: #252526; border: 1px solid #3c3c3c; border-radius: 8px; padding: 25px; }}
        h1, h2 {{ color: #9cdcfe; border-bottom: 2px solid #4a4a4a; padding-bottom: 10px; }}
        .mermaid {{ background-color: #2a2d34; border: 1px solid #4a4a4a; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 30px; }}
        .service-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 20px; }}
        .service-card {{ background-color: #2a2d34; border: 1px solid #4a4a4a; border-radius: 8px; padding: 20px; display: flex; flex-direction: column; }}
        .service-card h3 {{ margin-top: 0; color: #569cd6; }}
        .service-card code {{ background-color: #1e1e1e; color: #ce9178; padding: 2px 6px; border-radius: 4px; font-family: "Fira Code", "Courier New", monospace; }}
        .service-card ul {{ padding-left: 20px; margin-top: 10px; }}
        .service-card li {{ margin-bottom: 8px; }}
        .function-list {{ margin-top: 15px; border-top: 1px solid #4a4a4a; padding-top: 15px; }}
        .function-list h4 {{ margin-top: 0; color: #4ec9b0; }}
        .function-list dl {{ margin: 0; }}
        .function-list dt {{ font-weight: bold; color: #dcdcaa; margin-top: 15px; }}
        .function-list dd {{ margin-left: 20px; font-size: 0.9em; color: #c8c8c8; }}
        .function-list dd ul {{ list-style-type: '- '; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>MAAI Experiment Service Interaction Flow</h1>
        <p>This document is dynamically generated by analyzing the project's source code. It provides a graphical and textual overview of the service interactions when <code>run_config.py</code> is executed.</p>
        <h2>Execution Sequence Diagram</h2>
        <div class="mermaid">
sequenceDiagram
    actor User
    participant EntryPoint as "run_config.py"
    participant DM as "DeliberationManager"
    participant EO as "ExperimentOrchestrator"
    participant CM as "ConfigManager"
    participant ConvS as "ConversationService"
    participant MemS as "MemoryService"
    participant ConS as "ConsensusService"
    participant EvalS as "EvaluationService"
    participant DE as "DataExporter"

    User->>EntryPoint: Executes python run_config.py
    activate EntryPoint

    EntryPoint->>CM: load_config_from_file()
    activate CM
    CM-->>EntryPoint: ExperimentConfig
    deactivate CM

    EntryPoint->>DM: run_single_experiment(config)
    activate DM

    DM->>EO: run_experiment(config)
    activate EO

    Note over EO: Phase 1: Initialization
    EO->>EO: _initialize_agents()
    EO->>MemS: initialize_agent_memory() for each agent
    activate MemS
    MemS-->>EO: memories initialized
    deactivate MemS

    Note over EO: Phase 2: Initial Likert Assessment
    EO->>ConvS: conduct_initial_likert_assessment()
    activate ConvS
    ConvS->>EvalS: conduct_initial_assessment()
    activate EvalS
    EvalS-->>ConvS: InitialEvaluationResponses
    deactivate EvalS
    ConvS-->>EO: InitialEvaluationResponses
    deactivate ConvS

    Note over EO: Phase 3: Initial Choice Evaluation
    EO->>ConvS: conduct_initial_evaluation()
    activate ConvS
    ConvS-->>EO: Transcript updated
    deactivate ConvS
    EO->>ConS: detect_consensus()
    activate ConS
    ConS-->>EO: Initial ConsensusResult
    deactivate ConS

    Note over EO: Phase 4: Deliberation Loop
    loop Deliberation Rounds
        EO->>ConvS: generate_speaking_order()
        activate ConvS
        ConvS-->>EO: Speaking Order
        deactivate ConvS

        EO->>ConvS: conduct_round()
        activate ConvS
        Note right of ConvS: For each agent in order...
        ConvS->>MemS: update_agent_memory()
        activate MemS
        MemS-->>ConvS: New MemoryEntry
        deactivate MemS
        ConvS->>ConvS: _generate_public_communication()
        ConvS-->>EO: Transcript updated
        deactivate ConvS

        EO->>ConS: detect_consensus()
        activate ConS
        ConS-->>EO: Round ConsensusResult
        deactivate ConS
        alt Consensus Reached
            EO->>EO: break loop
        end
    end

    Note over EO: Phase 5: Post-Consensus Evaluation
    EO->>EvalS: conduct_parallel_evaluation()
    activate EvalS
    EvalS-->>EO: Final EvaluationResponses
    deactivate EvalS

    Note over EO: Phase 6 & 7: Finalize
    EO->>EO: _collect_feedback()
    EO->>EO: _finalize_results()

    Note over EO: Phase 8: Export
    EO->>DE: export_experiment_data(results)
    activate DE
    DE-->>EO: File paths
    deactivate DE

    EO-->>DM: ExperimentResults
    deactivate EO
    DM-->>EntryPoint: ExperimentResults
    deactivate DM
    EntryPoint-->>User: Prints summary to console
    deactivate EntryPoint
        </div>
        <h2>Core Service Descriptions</h2>
        <div class="service-grid">
            {service_cards_html}
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({{ startOnLoad: true, theme: 'dark' }});</script>
</body>
</html>
"""

SERVICE_CARD_TEMPLATE = """
<div class="service-card">
    <h3>{service_name}</h3>
    <code>{file_path}</code>
    <p><strong>Role:</strong> {role}</p>
    <p>{description}</p>
    <ul>
        <li><strong>Calls:</strong> {calls}</li>
        <li><strong>Called by:</strong> {called_by}</li>
    </ul>
    <div class="function-list">
        <h4>Key Functions</h4>
        <dl>{functions_html}</dl>
    </div>
</div>
"""

FUNCTION_TEMPLATE = """
<dt><code>{func_name}({params})</code></dt>
<dd>
    <strong>Input:</strong><ul>{inputs_html}</ul>
    <strong>Output:</strong> <code>{outputs}</code><br/>
    <p>{description}</p>
</dd>
"""

# --- DYNAMIC ANALYSIS ENGINE ---

def _unparse_annotation(node):
    """Recursively unparses an AST annotation node back into a string."""
    if node is None:
        return "Any"
    if isinstance(node, ast.Name):
        return node.id
    if isinstance(node, ast.Subscript):
        value = _unparse_annotation(node.value)
        slice_val = _unparse_annotation(node.slice)
        return f"{value}[{slice_val}]"
    if isinstance(node, ast.Attribute):
        return f"{_unparse_annotation(node.value)}.{node.attr}"
    if isinstance(node, ast.Tuple):
        return ", ".join([_unparse_annotation(e) for e in node.elts])
    if isinstance(node, ast.Constant):
        return str(node.value)
    return ast.dump(node) # Fallback for complex/unhandled types

class ServiceVisitor(ast.NodeVisitor):
    """AST visitor to extract class, function, and import information."""
    def __init__(self, file_path):
        self.data = {
            'class_name': None,
            'class_docstring': "No description available.",
            'functions': [],
            'imports': set()
        }
        self.file_path = file_path

    def visit_ClassDef(self, node):
        self.data['class_name'] = node.name
        docstring = ast.get_docstring(node)
        if docstring:
            self.data['class_docstring'] = docstring.strip()
        self.generic_visit(node)

    def visit_FunctionDef(self, node):
        self._process_function(node)

    def visit_AsyncFunctionDef(self, node):
        self._process_function(node)

    def visit_ImportFrom(self, node):
        if node.module:
            # Handle relative imports (e.g., from ..core.models)
            if node.level > 0:
                base_path = os.path.dirname(self.file_path)
                # Go up `level` directories
                for _ in range(node.level):
                    base_path = os.path.dirname(base_path)
                # This is a simplification; doesn't resolve full module path perfectly but works for this project structure
                module_name = node.module.split('.')[-1]
                self.data['imports'].add(module_name)
            else:
                self.data['imports'].add(node.module.split('.')[-1])

    def _process_function(self, node):
        func_name = node.name
        if func_name.startswith('_'): # Ignore private methods
            return

        docstring = ast.get_docstring(node) or ""
        func_desc = docstring.split('Args:')[0].strip().replace('\n', '<br/>')

        # Extract inputs from type hints
        inputs = []
        for arg in node.args.args:
            if arg.arg == 'self':
                continue
            arg_name = arg.arg
            arg_type = _unparse_annotation(arg.annotation)
            inputs.append(f"<li><code>{arg_name}</code>: {arg_type}</li>")
        
        # Extract output from type hints
        return_type = _unparse_annotation(node.returns)

        self.data['functions'].append({
            'name': func_name,
            'params': ", ".join([arg.arg for arg in node.args.args if arg.arg != 'self']),
            'inputs_html': "".join(inputs) if inputs else "<li>None</li>",
            'outputs': return_type,
            'description': func_desc
        })

def analyze_codebase(service_dir):
    """Analyzes the service directory to build a map of services and their relations."""
    service_files = glob.glob(os.path.join(service_dir, "*.py"))
    service_data = {}
    
    # First pass: parse all files
    for file_path in service_files:
        if "__init__" in file_path: continue
        
        with open(file_path, 'r') as f:
            content = f.read()
            try:
                tree = ast.parse(content)
                visitor = ServiceVisitor(file_path)
                visitor.visit(tree)
                
                service_name = visitor.data['class_name']
                if service_name:
                    service_data[service_name] = visitor.data
                    service_data[service_name]['file_path'] = os.path.relpath(file_path, ROOT_DIR)
            except SyntaxError as e:
                print(f"Could not parse {file_path}: {e}")

    # Second pass: build relationship graph
    call_graph = defaultdict(set)
    called_by_graph = defaultdict(set)
    
    # Create a map from module name (e.g., 'consensus_service') to class name (e.g., 'ConsensusService')
    module_to_class_map = {}
    for class_name, data in service_data.items():
        module_name = os.path.basename(data['file_path']).replace('.py', '')
        module_to_class_map[module_name] = class_name

    for service_name, data in service_data.items():
        for imported_module in data['imports']:
            if imported_module in module_to_class_map:
                called_service_class = module_to_class_map[imported_module]
                call_graph[service_name].add(called_service_class)
                called_by_graph[called_service_class].add(service_name)

    return service_data, call_graph, called_by_graph

# --- HTML GENERATION ---

def generate_html(service_data, call_graph, called_by_graph):
    """Generates the final HTML content from the analyzed data."""
    service_cards_html = []
    
    # Sort services alphabetically for consistent output
    sorted_services = sorted(service_data.keys())

    for name in sorted_services:
        data = service_data[name]
        class_doc = data['class_docstring']
        
        # A simple way to extract role from docstring
        role = "Not specified."
        for line in class_doc.split('\n'):
            if line.strip().lower().startswith("role:"):
                role = line.strip()[5:].strip()
                break
        description = class_doc.split('\n\n')[0]

        functions_html = []
        for func in data["functions"]:
            functions_html.append(FUNCTION_TEMPLATE.format(
                func_name=func["name"],
                params=func["params"],
                inputs_html=func["inputs_html"],
                outputs=func["outputs"],
                description=func["description"]
            ))

        service_cards_html.append(SERVICE_CARD_TEMPLATE.format(
            service_name=name,
            file_path=data['file_path'],
            role=role,
            description=description,
            calls=", ".join(sorted(list(call_graph[name]))) or "None",
            called_by=", ".join(sorted(list(called_by_graph[name]))) or "None",
            functions_html="".join(functions_html)
        ))

    return HTML_TEMPLATE.format(service_cards_html="".join(service_cards_html))

# --- MAIN EXECUTION ---

def main():
    """Main function to drive the analysis and generation."""
    print(f"Analyzing service files in: {SERVICE_DIR}")
    service_data, call_graph, called_by_graph = analyze_codebase(SERVICE_DIR)
    
    if not service_data:
        print("Error: No service classes were found. Check the SERVICE_DIR path and file contents.")
        return

    print("Generating HTML overview...")
    final_html = generate_html(service_data, call_graph, called_by_graph)

    with open(OUTPUT_FILE, 'w') as f:
        f.write(final_html)

    print(f"Successfully generated dynamic service overview at: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
